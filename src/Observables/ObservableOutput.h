#ifndef OBSERVABLEOUTPUT_H_
#define OBSERVABLEOUTPUT_H_

#include <vector>
#include <fstream>

#include "BaseObservable.h"

/**
 * @brief Manages a single output stream.
 *
 * Instances of this class manage all the output streams associated to the simulation or to the analysis.
 * It stores a list of observables (derived from BaseObservable), whose results are then computed and printed
 * periodically. The constructor requires a string containing all the key=values associated to the instance.
 * The supported syntax is (optional values are between [])
 */

class ObservableOutput {
protected:
	std::vector<ObservablePtr> obss;
	std::ofstream output_stream;
	std::ostream *output;
	llint print_every;
	int append;
	int only_last;
	llint start_from;
	llint stop_at;
	std::string prefix;
	std::string output_name;
	std::string base_name;
	bool linear;
	int log_ppc;
	int log_n0;
	number log_fact;
	llint log_next;
	llint log_tot_cycle;
	int log_pos_in_cycle;
	int log_n_cycle;
	bool update_name_with_time;

	llint bytes_written;

	void open_output();
	void set_next_log_step();

public:
	/**
	 * @brief Constructor. The two arguments are mandatory (i.e. there are no other constructors in this class)
	 *
	 * @param stream_string a string containing all the key=values lines related to the object and to its associated observables
	 * @param sim_inp simulation input file
	 */
	ObservableOutput(std::string &stream_string);
	virtual ~ObservableOutput();

	/**
	 * @brief Initialize the object
	 */
	void init();

	/**
	 * @brief Add the given observable to this output's list of observables
	 *
	 * @param obs_string
	 */
	void add_observable(ObservablePtr new_obs);

	/**
	 * @brief Add the observable defined by obs_string to the list
	 *
	 * The observable will be appended to the observable list. The output order will reflect the order with which
	 * observable have been added to the list.
	 * @param obs_string A string containing the definition of the observable. The accepted syntax is
	 * type = observable name
	 * [additional, observable-dependent options as lines of 'key = value']
	 */
	void add_observable(std::string obs_string);

	/**
	 * @brief Clear the output of all the observables
	 */
	void clear();

	/**
	 * @brief Prints out the output generated by the stored observables
	 * @param step simulation step
	 */
	void print_output(llint step);

	/**
	 * @brief Changes the output stream. It only supports files (and not other kind of streams such as stdout or stderr)
	 *
	 * @param new_filename
	 */
	void change_output_file(std::string new_filename);

	/**
	 * @brief Checks whether the object is ready to print, and returns the result
	 * @param step simulation step
	 * @return true if the object is ready to print, false otherwise
	 */
	bool is_ready(llint step);

	/**
	 * @brief Returns the number of bytes written to the output file
	 *
	 */
	llint get_bytes_written() {
		return bytes_written;
	}

	/**
	 * @brief Returns the name of the file being written to as a string
	 *
	 */
	std::string get_output_name() {
		return output_name;
	}
};

using ObservableOutputPtr = std::shared_ptr<ObservableOutput>;

#endif /* OBSERVABLEOUTPUT_H_ */
